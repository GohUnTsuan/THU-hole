{"code": 0, "data": [{"cid": 1860761, "deleted": false, "image_metadata": {}, "is_dz": false, "name": "Alice", "pid": 364971, "reply_to": -1, "tag": null, "text": "在原洞回复就可以 不需要重新开贴", "timestamp": 1623775489, "type": "text", "url": ""}, {"cid": 1860849, "deleted": false, "image_metadata": {}, "is_dz": false, "name": "Bob", "pid": 364971, "reply_to": -1, "tag": null, "text": "1.9，我觉得是recursive function，是数理逻辑那一支（Godel）对可计算性的概念", "timestamp": 1623775932, "type": "text", "url": ""}, {"cid": 1860853, "deleted": false, "image_metadata": {}, "is_dz": false, "name": "Bob", "pid": 364971, "reply_to": -1, "tag": null, "text": "主要是谐音梗嘛，多读读就猜出来了（doge", "timestamp": 1623775952, "type": "text", "url": ""}, {"cid": 1861112, "deleted": false, "image_metadata": {}, "is_dz": true, "name": "洞主", "pid": 364971, "reply_to": 1860853, "tag": null, "text": "Re Bob: tql…并没有学过这个", "timestamp": 1623777246, "type": "text", "url": ""}], "post": {"deleted": false, "image_metadata": {}, "likenum": 8, "pid": 364971, "reply": 4, "tag": null, "text": "#364761 注释\n\n（本人学术不精，说错了求指出求轻喷）\n\n1.9 lambda calculus，即λ-演算，一种抽象的形式化的运算系统，可计算理论的基石之一，最小的通用程序设计语言。另一个没听过orz\n\n1.13 从这里开始是图灵机介绍。首先是一个忒普--tape--纸带。无限长的纸带，相当于无限大的一维存储器。纸带上可以写纸带字符。如果是二进制计算机相当于字符不是0就是1.当然也可以是十进制数字或者英文字母这种。纸带字符集必须是有限集，且包括空白符。仅允许空白符出现无数次。纸带有左端而无右端（即单带单向图灵机）\n1.15 海德--head--读写头，作用之后讲。\n1.16 斯忒特--state--状态。一个图灵机的状态是有限的。比如CPU的寄存器个数是有限的，每个寄存器宽度是有限的，因此CPU的状态就是有限的。状态必须包括初始状态和停机状态。除了停机状态还可以有各种中间状态。（注：各种CPU配合存储器都相当于通用图灵机）\n1.17 川榭雄--transition--转移，就是说他负责来执行转移函数。转移函数：输入为当前状态和当前head读到的纸带字符，输出为下一状态、往当前格子里写的字符和下一步head是往左还是往右走。\n1.19 图灵机工作原理：最初head在最左侧格子，状态为初始状态。在每一个计算周期，head读取当前格子的字符，连着当前状态一起给transition。transition执行预定义的转移函数，把当前状态和当前格子里的字符设置为转移函数的输出，然后按照转移函数的指令左移或者右移。对于CPU而言，转移函数相当于指令集的实现，即从哪个内存单元读数，将哪些寄存器进行怎样的运算，将哪个寄存器写入哪个内存单元等等。\n1.21 对于一般的数学计算问题（例如：找出第10000个质数），停机状态分为接受--accept和拒绝--reject两种。如果状态转移到接受，就输出1（找到了），如果状态转移到拒绝状态，就输出0（没找到）。\n1.22和1.24 图灵等人证明了，任何可计算的问题，都可以等价的表示为某一种图灵机。\n1.25 图灵证明了，双向图灵机和单向图灵机等价。\n1.26 图灵证明了多带图灵机和单带图灵机等价。（因此上文不需要强调是单向单带图灵机）\n1.27 如果转移函数是多输出函数，即一种输入同时对应多种输出，随机选择一种输出执行，称为非确定图灵机。图灵证明了非确定图灵机和确定性图灵机等价。\n1.28 可计算理论的另一个基石——丘奇图灵论题：任何一个函数是可计算的当且仅当可由一部图灵机来计算它\n\n1.32 由于图灵机比较难描述，就把一些可计算的操作定义成语法。这些操作包含分支结构(if-else)和循环结构(for loop)，以及一些基本运算。用这些基本运算和操作构成了各种编程语言，再使用语言进行编程，就相当于是定义一种图灵机来解决问题。\n1.34 由于以上的图灵机自身的定义是可数的（规定了字符集的有限等等），因此存在一种通用图灵机可以模拟其他图灵机。不同的通用图灵机之间可以相互模拟。既然可以模拟那么就可以调用。因此编程语言可以包括函数的调用。\n1.36 另一个大神证明了函数的参数传递是可以用图灵机做的。\n1.37 综合以上几条，把包含基本运算、分支和循环结构、函数调用的语言称为伪代码。一切可计算问题都等价于一套伪代码。这种表示比图灵机表示方便很多，但它们又是完全等价的。\n（注：所有的CPU指令集都是在近似实现伪代码，因此CPU都近似等价于通用图灵机（除了存储和精度限制）。高级编程语言经过编译被翻译成机器语言（即指令集里的指令的序列），因此所有高级语言都近似等价于通用图灵机。同一种伪代码可以用不同高级语言实现，实现后编译在不同的CPU上执行，结果相同，这本质上是不同的图灵机相互模拟的过程）\n\n1.38 计算复杂度的概念，包括时间复杂度和空间复杂度。多项式时间能计算的问题是好的问题（P），称为多项式时间复杂度。\n1.39 程序设计的通用目标就是追求更小的时间复杂度和空间复杂度。\n\n***\n感谢原dz，把晦涩抽象的计算理论写的生动有趣，受教了", "timestamp": 1623775456, "type": "text", "updated_at": 1623777244, "url": "", "vote": {}}}